# 정규표현식 & 효율적 소인수분해 알고리즘

## 1. 정규표현식 (Regular Expressions)

*   **발표자:** 소프트웨어학과 손영빈 (2021663041)

### 1.1. 정규표현식(Regex)이란?

*   **패턴 언어:** 특정 규칙을 가진 문자열의 집합을 표현하는 형식 언어. 문자열 속 특정 패턴을 찾아내는 데 사용됩니다.
*   **다양한 활용:** 텍스트 내에서 원하는 패턴을 정의하여 탐색, 추출, 변환이 가능하며, 데이터 처리 작업을 자동화합니다.
*   **보편적 명칭:** Regular Expression, Regex로 불리며 전 세계 개발자들이 사용하는 표준 도구이다.

### 1.2. 배워야 하는 이유

*   **자동화:** 이메일, 전화번호 등 패턴을 자동으로 탐지하고 검증하여 수작업을 줄입니다.
*   **데이터 처리:** 데이터 정제, 로그 분석, 텍스트 치환 등 실무에서 필수적인 작업을 효율적으로 수행합니다.
*   **범용성:** 파이썬, 자바스크립트, 자바 등 다양한 프로그래밍 언어에서 표준으로 지원됩니다.

### 1.3. 대표적인 패턴과 의미

| 패턴        | 의미                                  |
| :---------- | :------------------------------------ |
| `x`         | 문자 x                                |
| `xyz`       | 문자열 xyz                            |
| `[xyz]`     | x, y, z 중 하나                       |
| `[a-z]`     | a부터 z까지 중 하나                   |
| `[^xyz]`    | x, y, z가 아닌 문자                   |
| `{숫자}`    | 반복 횟수 지정 (예: `a{3}`는 "aaa")   |
| `^x`        | x로 시작                              |
| `x$`        | x로 끝남                              |
| `.`         | 아무 문자 하나 (줄바꿈 문자 제외 가능) |
| `x+`        | 1개 이상의 x                          |
| `x*`        | 0개 이상의 x                          |
| `x?`        | 0 또는 1개의 x                        |
| `\d`        | 숫자 (0-9)                            |
| `\D`        | 숫자가 아닌 문자                      |
| `\w`        | 영문자, 숫자, 언더바 (`_`)            |
| `\W`        | `\w`가 아닌 문자                      |
| `\s`        | 공백 문자 (스페이스, 탭, 줄바꿈 등)   |
| `\S`        | 공백 아닌 문자                        |
| `\t`        | 탭                                    |
| `\n`        | 줄바꿈                                |

### 1.4. 자주 사용하는 정규표현식 예제

*   **숫자만 허용:** `^[0-9]+$` (예: `123456`)
*   **영문자만 허용:** `^[a-zA-Z]+$` (예: `abcDEF`)
*   **한글만 허용:** `^[가-힣]+$` (예: `가나다라`)
*   **전화번호:** `^\d{2,3}-\d{3,4}-\d{4}$` (예: `02-1234-5678`, `010-1234-5678`)
*   **비밀번호 (알파벳+숫자, 6~12자리):** `^[a-zA-Z0-9]{6,12}$` (예: `aB123456`)
*   **이메일:** `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$` (예: `test@naver.com`)
*   **아이디 (소문자, 숫자, `_`, `-`, 2~10자리):** `^[a-z0-9_-]{2,10}$` (예: `ab_12`)

### 1.5. 실전 예제

*   **이메일 검증:** `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
*   **전화번호 추출 (010 국한):** `010-\d{3,4}-\d{4}`
*   **HTML 태그 제거:** `<.*?>` (주의: 간단한 경우에만 사용, 복잡한 HTML 파싱에는 부적합)

### 1.6. 정규표현식 실습 도구

*   **웹 기반 도구:** regex101.com, regextester.com 등 (실시간 테스트 및 결과 확인)
*   **텍스트 에디터:** VS Code, Sublime Text 등 (강력한 정규표현식 검색 및 치환 기능 내장)
*   **프로그래밍 언어:**
    *   Python: `re` 모듈
    *   JavaScript: `RegExp` 객체

### 1.7. 파이썬 `re` 활용 예시 (HTML 태그 제거)

```python
import re

html_content = "<p>Hello <b>world</b>!</p>"
# <.*?> : HTML 태그를 찾는 정규표현식
# ""    : 매칭된 부분을 빈 문자열로 바꿈 (제거)
text_only = re.sub(r"<.*?>", "", html_content)
print(text_only) # 결과: Hello world!
```

### 1.8. 주의점 및 팁

1.  **단순화:** 과도하게 복잡한 패턴은 가독성과 성능을 저하시킵니다. 가능한 단순하게 유지하세요.
2.  **검증:** 작은 단위부터 점진적으로 패턴을 확장하고 항상 테스트하세요. 눈으로 결과를 확인하는 습관이 중요합니다.
3.  **실습:** 다양한 실전 예제로 숙련도를 높이세요. 정규표현식은 많이 써볼수록 익숙해집니다.

---

## 2. 효율적 소인수분해 알고리즘

*   **발표자:** 2025964048 최우석
*   **주요 알고리즘:** Pollard's Rho Algorithm & Miller-Rabin Primality Test

### 2.1. 연구 동기: RSA 암호 시스템

*   RSA는 두 개의 큰 소수 `p`, `q`의 곱 `N = p * q`를 사용하는 공개키 암호 방식입니다.
*   `N`과 공개키 `e`는 공개되지만, 개인키 `d`는 `φ(N) = (p-1)(q-1)`을 알아야 계산 가능합니다.
*   `N`을 소인수분해하여 `p`와 `q`를 찾는 것이 RSA 해독의 핵심이며, `N`이 매우 크면 소인수분해가 매우 어렵다는 점에 기반합니다.
    *   예시: `2,301,883,971,777,917 = 39487603 × 58293839`

### 2.2. 소수 판별법: 밀러-라빈 소수 판별법 (Miller-Rabin Primality Test)

*   **개요:** 확률적 소수 판별 알고리즘으로, 어떤 수가 소수일 가능성이 매우 높음을 빠르게 판단합니다.
*   **기반 이론:**
    1.  **페르마의 소정리:** `p`가 소수이고 `a`가 `p`의 배수가 아니면, `a^(p-1) ≡ 1 (mod p)`
    2.  **보조 정리:** `p`가 소수이고 `x² ≡ 1 (mod p)`이면, `x ≡ 1 (mod p)` 또는 `x ≡ -1 (mod p)`
*   **알고리즘 아이디어:**
    1.  판별할 홀수 `N > 2`에 대해 `N-1 = d * 2^s` (단, `d`는 홀수)로 표현합니다.
    2.  임의의 정수 `a` (1 < `a` < `N-1`)를 선택합니다.
    3.  다음 조건 중 하나라도 만족하면 `N`은 *아마도* 소수입니다:
        *   `a^d ≡ 1 (mod N)`
        *   어떤 `r` (0 ≤ `r` < `s`)에 대해 `a^(d * 2^r) ≡ -1 (mod N)`
    4.  위 조건을 만족하지 않으면 `N`은 합성수입니다.
    5.  여러 `a` 값에 대해 반복하여 정확도를 높입니다. (특정 `a` 값들을 사용하면 특정 범위 내 수에 대해 결정론적으로 판별 가능)
*   **시간 복잡도:** `O(k * (log N)³)` (k는 테스트 횟수)

### 2.3. 큰 합성수의 약수 찾기: 폴라드 로 알고리즘 (Pollard's Rho Algorithm)

*   **개요:** 합성수 `N`의 비자명(non-trivial) 인수를 찾는 확률적 알고리즘. 사이클 탐지 기법을 사용합니다.
*   **아이디어 (생일 문제와 유사):**
    *   함수 `f(x) = (x² + c) mod N` (c는 보통 1 또는 -1)을 사용하여 수열 `x_0, x_1=f(x_0), x_2=f(x_1), ...` 생성합니다.
    *   `N`의 어떤 소인수 `p`에 대해, 수열 `x_i mod p`는 결국 사이클을 형성합니다.
    *   플로이드의 사이클 찾기 알고리즘 (거북이와 토끼: `x_i`와 `x_{2i}` 비교)을 사용합니다.
    *   만약 `x_i ≡ x_{2i} (mod p)` 이면, `p`는 `|x_i - x_{2i}|`의 약수입니다.
    *   따라서 `d = gcd(|x_i - x_{2i}|, N)`을 계산했을 때, `1 < d < N`이면 `d`는 `N`의 인수입니다.
    *   `d = N`이면 실패 (다른 `x_0`나 `c`로 재시도).
    *   `d = 1`이면 계속 진행.
*   **기대 시간 복잡도:** `O(N^(1/4))` 또는 `O(√p)` (p는 N의 가장 작은 소인수)

### 2.4. 효율적 소인수분해 알고리즘 (종합)

1.  **약수 찾기:** 폴라드 로 알고리즘을 사용하여 주어진 수 `N`의 인수 `d`를 찾습니다.
2.  **소수 판별:** 찾은 인수 `d`가 소수인지 밀러-라빈 소수 판별법으로 확인합니다.
    *   `d`가 소수이면 소인수 목록에 추가하고 `N`을 `d`로 나눕니다.
    *   `d`가 합성수이면 `d`에 대해 다시 소인수분해 알고리즘을 재귀적으로 적용합니다.
3.  **반복:** `N`이 1이 되거나, 남은 `N`이 밀러-라빈 판별법에 의해 소수로 판별될 때까지 반복합니다.


---
